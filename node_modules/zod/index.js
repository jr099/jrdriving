class ZodError extends Error {
  constructor(issues) {
    super(issues.map((issue) => `${issue.path.join('.')}: ${issue.message}`).join('\n'));
    this.issues = issues;
    this.name = 'ZodError';
  }
}

class ZodType {
  optional() {
    return new ZodOptional(this);
  }

  nullable() {
    return new ZodNullable(this);
  }

  safeParse(data) {
    const result = this._parse(data, []);
    if (result.success) {
      return { success: true, data: result.data };
    }
    return { success: false, error: new ZodError(result.issues) };
  }
}

class ZodString extends ZodType {
  constructor() {
    super();
    this.validators = [];
  }

  _parse(data, path) {
    if (typeof data !== 'string') {
      return { success: false, issues: [{ path, message: 'Expected string' }] };
    }

    for (const validator of this.validators) {
      const errorMessage = validator(data, path);
      if (errorMessage) {
        return { success: false, issues: [{ path, message: errorMessage }] };
      }
    }

    return { success: true, data };
  }

  min(length, message) {
    this.validators.push((value) =>
      value.length >= length ? null : message ?? `Must contain at least ${length} characters`
    );
    return this;
  }

  max(length, message) {
    this.validators.push((value) =>
      value.length <= length ? null : message ?? `Must contain at most ${length} characters`
    );
    return this;
  }

  email(message = 'Invalid email') {
    const emailRegex = /^(?:[^\s@]+@[^\s@]+\.[^\s@]+)$/;
    this.validators.push((value) => (emailRegex.test(value) ? null : message));
    return this;
  }

  regex(pattern, message = 'Invalid format') {
    this.validators.push((value) => (pattern.test(value) ? null : message));
    return this;
  }
}

class ZodNullable extends ZodType {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  _parse(data, path) {
    if (data === null) {
      return { success: true, data: null };
    }
    return this.inner._parse(data, path);
  }
}

class ZodOptional extends ZodType {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  _parse(data, path) {
    if (typeof data === 'undefined') {
      return { success: true, data: undefined };
    }
    return this.inner._parse(data, path);
  }
}

class ZodObject extends ZodType {
  constructor(shape) {
    super();
    this.shape = shape;
  }

  _parse(data, path) {
    if (typeof data !== 'object' || data === null || Array.isArray(data)) {
      return { success: false, issues: [{ path, message: 'Expected object' }] };
    }

    const typedData = data;
    const result = {};
    const issues = [];

    for (const key of Object.keys(this.shape)) {
      const schema = this.shape[key];
      const childPath = [...path, key];
      const value = typedData[key];
      const parsed = schema._parse(value, childPath);
      if (parsed.success) {
        result[key] = parsed.data;
      } else {
        issues.push(...parsed.issues);
      }
    }

    if (issues.length > 0) {
      return { success: false, issues };
    }

    return { success: true, data: result };
  }
}

const z = {
  string() {
    return new ZodString();
  },
  object(shape) {
    return new ZodObject(shape);
  },
};

module.exports = { z, ZodError, ZodType };
